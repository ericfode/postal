= POSTAL - Protocol Spcification.
Andrey Antukh, <niwi@niwi.nz>
Version 1.0
:toc:
:toc-title:
:toclevels: 2
:!numbered:
:idseparator: -
:idprefix:
:source-highlighter: pygments
:pygments-style: friendly
:sectlinks:


== Abstract

POSTAL is a simple and interoperable protocol designed for asynchronous message based
client-to-server communication. It is defined as plain-text format for better
interoperability and intends to be used on top of WebSockets or socket/message based
communication protocols (nanomsg, zeromq, etc.).


== Rationale

The POSTAL protocol is originated from the need of a simple, client-to-server,
asynchronous, message based protocol for the http layer (communicate browsers with servers
using message based communication with similar semantics of HTTP).

The unique real alternative to POSTAL is _STOMP_ but, the last one is designed to work
with message brokers with limited set of communication schemes such as topic and queue.
That communication schemes are very flexible, but mount something like RPC on top of it
usually adds a great amount of accidental complexity.

In summary: _STOMP_ is too much high level protocol.

POSTAL intends to be a client-to-server communication instead client-to-broker (actors
model) with similar semantis borrowed from HTTP for communicate clients that want send
asynchronous request to server.

Reliability and backpressure is one of the first goals of the POSTAL protocol.


== Protocol Overview

POSTAL is a frame based protocol with frames modeled in the same way as _STOMP_ or
HTTP. A frame consists in a command, a set of headers and an optional body.
The default encoding of the POSTAL frame is *UTF-8*.

The POSTAL server is modeled as set of endpoints "a la" HTTP to which a messages can
be sent. The message reception it should be reliable and with mandatory acknowledge.


=== Frames

POSTAL is a frame based protocol that assumes a reliable 2-way streaming network
protocol (such as TCP or WebSockets). THhe client and server will communicate ussing
POSTAL frames sent over the stream. A frame's structure looks like:

[source, text]
----
COMMAND
header1:value1
header2:value2

body
----

The frame does not have explicit delimiters because it intends to be used on top of
low-level message based protocols like *websockets*, *nanomsg* or *zeromq*. So if you
want use it on top of TCP, you should use your own technique for determie the frame.


=== Headers

Some headers MAY be used, and have special meaning, with most frames.


==== Header: *id*

The `id` header serves for identify messages. It is mainly used by client frames. Frames
without specified `id` does not return responses. And some frames has `id` as mandatory
header.


==== Header: *content-type*

Is a optional header. Indicates the type of data comes in the body of the message.
The server can be smart and decode the message before delegate the message to the
user defined handler.


==== Repeated Header Entries

If a client or a server receives repeated frame header entries, only the first header
entry SHOULD be used as the value of header entry. Subsequent values are only used to
maintain a history of state changes of the header and MAY be ignored.


=== Size Limits

To prevent malicious clients from exploiting memory allocation in a server, servers MAY
place maximum limits on:

* the number of frame headers allowed in a single frame
* the maximum length of header lines
* the maximum size of a frame body

If these limits are exceeded the server SHOULD send the client an ERROR frame.


== Common Frames

=== HELLO

A POSTAL client initializes the communication with the server sending a `HELLO` frame:

[source, text]
----
HELLO
heart-beat: 2

^@
----

The server should respond also with `HELLO` frame:

[source, text]
----
HELLO
server: catacumba/0.4.0 (netty)

^@
----


=== ACK

Is a generic frame that is used for acknowledge the messages received by the server.
It represents the signal that the server have recived a message. Is a body less
version of `RESPONSE` frame.

This is aspect of the `ACK` frame:

[source, text]
----
ACK
message-id: e11a27d3-4b86-4191-a310-12847fa79d48

^@
----

The `ACK` frames should mandatory identify the associated message. So if a message
sent to the server does not provide any identification id, the `ACK` frame should
not to be send by server.


=== ERROR

Is a generic frame that represents a error situation. This kind of messages can be send
by server when something goes wrong.

This is aspect of the `ERROR` frame:

[source, text]
----
ERROR
content-type: application/json
content-length: 31
code: 404

{"message": "Does not exists."}^@
----

The `ERROR` frame has `code` as mandatory header and it is represents a error code. The
POSTAL protocol will define a little subset of semantic errors that can be used by
your application or define your own error codes.


=== RESPONSE

This is a generic frame that represents a server response to some kind of request. This
frame is mainly used by REQ/REP scalability protocols explained below.

This is aspect of the `RESPONSE` frame:

[source, text]
----
RESPONSE
message-id: e11a27d3-4b86-4191-a310-12847fa79d48
content-type: application/json
content-length: 31

{"id": 1, "first_name": "Yennefer"}^@
----

The `message-id` is a mandatory header that allow a client pair the response to the
previous request frame. If a request message does not comes with `id` attribute,
the response will not be sent by server.


=== MESSAGE

This is a generic frame that represents a server message. This frame is very similar
purpose that `RESPONSE` but very different semantics. This frame can be sent by server
in any moment, without client intervention.

Mainly used for consume messages from subscriptions or from queues. See more PUB/SUB and
PUSH/PULL scalability protocols.

This is aspect of the `RESPONSE` frame:

[source, text]
----
MESSAGE
subscription: e11a27d3-4b86-4191-a310-12847fa79d48
content-type: application/json
content-length: 31

{"id": 1, "first_name": "Yennefer"}^@
----


=== PING

This is a server frame that's used for the keepalive control.

[source, text]
----
PING
id: 1

^@
----


=== PONG

This is a client frame that's used for reply the `PING` frames. Also used for keepalive
control.

----
PONG
id:1

^@
----


== REQ/REP

This section will contain frames that are part ot the REQ/REP scalability protocol.


=== QUERY

This is a frame that should be used for request data from specified resource. It has very
similar semantics to the HTTP GET request.

This is the aspect of the `QUERY` frame:

[source, text]
----
QUERY
id: e11a27d3-4b86-4191-a310-12847fa79d48
destination: /user/2

^@
----

After sending a `QUERY` frame we should expect an `RESPONSE` frame from the server
unless the `id` header is ommited. The `destination` header is mandatory and it is
represented as URI path.


=== NOVELTY

This is a frame that serves for submit data to be processed to a specified resource. It
has versy similar semantics that HTTP POST requests.

This is the aspect of the `NOVELTY` frame:

[source, text]
----
NOVELTY
id: e11a27d3-4b86-4191-a310-12847fa79d48
content-type: application/edn
destination: /user/2

[[:db/add 857582744 :username "foobar"]
 [:db/add 857582744 :password "secret"]]^@
----

After sending a `NOVELTY` frame we should expect an `RESPONSE` to be sent back.
The `destination` header is mandatory and it is represented as URI path.


== PUB/SUB

This section will contain frames that are part ot the PUB/SUB scalability protocol.


=== SUBSCRIBE

This is a frame that's should be used for notify the server that a client want subscribe
to a specific topic.

[source, text]
----
SUBSCRIBE
id: e11a27d3-4b86-4191-a310-12847fa79d48
topic: user.notifications

^@
----

The *id* and *topic* headers are mandatory.

As consecuence of send this frame, the server should send back to the client the `ACK`
frame confirming that the subscription is made successfully.

[source, text]
----
ACK
id: e11a27d3-4b86-4191-a310-12847fa79d48
topic: user.notifications

^@
----

The implementation of the subscription mechanism is user defined. This spec does not
covers any low-level aspect. The `SUBSCRIBE` has just a semantic name. Nothing prevents
to the user use `SUBSCRIBE` frames to something different.

Then the subscription is established, the server may start send you arbitrary number
of `MESSAGE` frames identified by the topic:

[source, text]
----
MESSAGE
id: e11a27d3-4b86-4191-a310-12847fa79d48
topic: user.notifications
content-type: application/edn

{:foo "bar"}^@
----

WARNING: Nothing prevents server send `MESSAGE` frames independently if you have done a
subscription or not (ex: the server can start sending notifications to the client at
any time, no subscription action is nedded). The `SUBSCRIBE` frame is a semantic frame
that allows subscription negotiation if the user needs it.


=== UNSUBSCRIBE

This is a frame that should be used for cancel a subscription.

[source, text]
----
UNSUBSCRIBE
id: e11a27d3-4b86-4191-a310-12847fa79d48
topic: user.notifications
----

As consecuence of send this frame, the server should send back to the client the `ACK`
frame confirming that the server had successfully removed the subscription.


=== PUBLISH

This is a frame that should be used for publish a message in a specified topic. If a
client is also subscribed to the topic, it will receive the published message.

[source, text]
----
PUBLISH
id: e11a27d3-4b86-4191-a310-12847fa79d48
topic: user.notifications
content-type: application/edn

{:message "content"}^@
----


As consecuence of send this frame, the server should send back to the client the `ACK`
frame confirming that the publish is done successfully.

[source, text]
----
ACK
id: e11a27d3-4b86-4191-a310-12847fa79d48

^@
----


== PUSH/PULL

This section will contain frames that are part ot the PUSH/PULL scalability protocol.

=== PUT

TBD


=== TAKE

TBD


=== CONSUME

TBD



== License

_catacumba_ is licensed under BSD (2-Clause) license:

----
Copyright (c) 2015 Andrey Antukh <niwi@niwi.nz>

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
----
